/**
This is file is made to write all the stuff we figure out about C lenguage.
Similar as slack App.
**/

START-

CURIOSDAD: Variables y globales. Evitar doble definicion y sus complicaciones.
//The compiler or the makefile processed the global vars twice, throwing E.
/*The error of duplicate load about this two globals variables
was that their types were instances variables so when the compiler
build both files that use this header file, the variable were initializated
twice, to avoid it, it was necessary to change their types to static, meaning
that these variables are just gonna get initialized once.

The big headache is the global variable must be used in every c.file,
as ft_printf.c and ft_printf_parser.c and so on, so this is not the best
way to approach this problem.
*/
static char	g_cnv[9] = {'c', 's', 'p','d', 'i', 'u', 'x', 'X', '%'};
static char	g_flgs[6] = {'#', '0', '-', '.', ' ', '+'};

Also the implementation made it was a string of characters wrapping all the
conversors specifiers: "cspdiuxX%"

FIN-

START-

RECORDATORIO: Acerca de variables y direcciones de memoria.

int	ft_parser(char *fstr, t_fstr *root)
{
	...
	ft_set_nd(&fstr, root, &off);
}

int	ft_set_nd(char **fstr, t_fstr *root, char **off)
{
	while ((**fstr)++ != (*conv)++);
}

Hipotesis 1:

EL error ocasionado en el while se explica como sigue:
1. EL puntero fstr se indirecciona doblemente con el operador *
2. AL haberse indireccionado doblemente, se convierte en un caracter.
3. Incrementar un caracter no corresponde a incrementar un puntero.
4. El puntero conv, se indirecciona a caracter e igualmente se incrementa,
	lo cual no corresponde a incrementar el puntero.

Hipotesis 2:
1. El puntero se incrementa no al puntero que apunta a la cadena de caracteres
	si no que incrementa al puntero que apunta al puntero mencionado anteriormente.
	Lo cual causa el segmentation fault.

while (*(*fstr)++ != *conv++ && printf("D:\t %c - %c\n", **fstr, *conv));

El while superior muestra la manera correcta en que se debian indireccionar
los punteros para que no ocurriera un segmentation fault.

D:	   - c
D:	 e - s
D:	 s - p
D:	   - d
D:	 u - i
D:	 n - u
D:	 a - x
D:	   - X
D:	 c - %
D:	 o - 
D:	 n - D
D:	 s - :
D:	 t - 	

ft_itoa, allow conversions of variable number to string. Removed, not needed.

static void	ft_memcpy(char *lf, char *tmp, int dig)
{
	*tmp++ = dig;
	while (*lf != '\0')
		*tmp++ = *lf++;
	return ;
}

static char	*ft_itoa(unsigned long int num, char *lf)
{
	int		counter;
	char	dig;
	char	*tmp;

	counter = 0;
	if (num == 0)
		return ("0");
	while (num != 0)
	{
		dig = num % 10 + '0';
		num = (num - num % 10) / 10;
		counter++;
		tmp = (char *) malloc(sizeof(char) * (counter + 1));
		if (tmp == NULL)
			return (NULL);
		*(tmp + counter) = '\0';
		if (counter == 1)
			*tmp = dig;
		else
			ft_memcpy(lf, tmp, dig);
		if (lf != NULL)
			free(lf);
		lf = tmp;
	}
	return (lf);
}
0 main:
int	main(void)
{
	// int	test;

	// test = 15;
	// printf("%2$+*3$.*1$d %1$d\n", 2, 1, test);
	// printf("%2$-+10.*3$d %1$d\n", 10, 3, 5); //show that it's not compulsory for field and precision an $ style.
	// printf("E%%%iaaaa%20.skkk%-10ubbb%#xWWW%20pZZZ\n", 0, "Holaaaa", 0, -123, &test);
	printf(" %.d \n", INT_MAX);
	printf(" %p \n", -1);
	printf(" %p \n", 1);
	printf(" %p \n", 15);
	printf(" %p \n", 16);
	printf(" %p \n", 17);
	printf(" %p %p \n", LONG_MIN, LONG_MAX);
	printf(" %p %p \n", INT_MIN, INT_MAX);
	printf(" %p %p \n", ULONG_MAX, -ULONG_MAX);
	printf(" %p %p \n", 0, 0);
	printf("Starting my implementation\n");
	ft_printf(" %.d \n", INT_MAX);
	ft_printf(" %p \n", -1);
	ft_printf(" %p \n", 1);
	ft_printf(" %p \n", 15);
	ft_printf(" %p \n", 16);
	ft_printf(" %p \n", 17);
	ft_printf(" %p %p \n", LONG_MIN, LONG_MAX);
	ft_printf(" %p %p \n", INT_MIN, INT_MAX);
	ft_printf(" %p %p \n", ULONG_MAX, -ULONG_MAX);
	ft_printf(" %p %p \n", 0, 0);
	// ft_printf("EEE%%%04.saaa%-15c%-+10.3d%20paaa%#xbbb%010u", "Holaaaa", 'B', 0, &test, -123, 0);
	// printf("\n");
	// ft_printf("E%%%iaaaa%20.skkk%-10ubbb%#xWWW%20pZZZ", 0, "Holaaaa", 0, -123, &test);
	// printf("\n");
	return (0);
}

