/**
This is file is made to write all the stuff we figure out about C lenguage.
Similar as slack App.
**/

START-

CURIOSDAD: Variables y globales. Evitar doble definicion y sus complicaciones.
//The compiler or the makefile processed the global vars twice, throwing E.
/*The error of duplicate load about this two globals variables
was that their types were instances variables so when the compiler
build both files that use this header file, the variable were initializated
twice, to avoid it, it was necessary to change their types to static, meaning
that these variables are just gonna get initialized once.

The big headache is the global variable must be used in every c.file,
as ft_printf.c and ft_printf_parser.c and so on, so this is not the best
way to approach this problem.
*/
static char	g_cnv[9] = {'c', 's', 'p','d', 'i', 'u', 'x', 'X', '%'};
static char	g_flgs[6] = {'#', '0', '-', '.', ' ', '+'};

Also the implementation made it was a string of characters wrapping all the
conversors specifiers: "cspdiuxX%"

FIN-

START-

RECORDATORIO: Acerca de variables y direcciones de memoria.

int	ft_parser(char *fstr, t_fstr *root)
{
	...
	ft_set_nd(&fstr, root, &off);
}

int	ft_set_nd(char **fstr, t_fstr *root, char **off)
{
	while ((**fstr)++ != (*conv)++);
}

Hipotesis 1:

EL error ocasionado en el while se explica como sigue:
1. EL puntero fstr se indirecciona doblemente con el operador *
2. AL haberse indireccionado doblemente, se convierte en un caracter.
3. Incrementar un caracter no corresponde a incrementar un puntero.
4. El puntero conv, se indirecciona a caracter e igualmente se incrementa,
	lo cual no corresponde a incrementar el puntero.

Hipotesis 2:
1. El puntero se incrementa no al puntero que apunta a la cadena de caracteres
	si no que incrementa al puntero que apunta al puntero mencionado anteriormente.
	Lo cual causa el segmentation fault.

while (*(*fstr)++ != *conv++ && printf("D:\t %c - %c\n", **fstr, *conv));

El while superior muestra la manera correcta en que se debian indireccionar
los punteros para que no ocurriera un segmentation fault.

D:	   - c
D:	 e - s
D:	 s - p
D:	   - d
D:	 u - i
D:	 n - u
D:	 a - x
D:	   - X
D:	 c - %
D:	 o - 
D:	 n - D
D:	 s - :
D:	 t - 	

ft_itoa, allow conversions of variable number to string. Removed, not needed.

static void	ft_memcpy(char *lf, char *tmp, int dig)
{
	*tmp++ = dig;
	while (*lf != '\0')
		*tmp++ = *lf++;
	return ;
}

static char	*ft_itoa(unsigned long int num, char *lf)
{
	int		counter;
	char	dig;
	char	*tmp;

	counter = 0;
	if (num == 0)
		return ("0");
	while (num != 0)
	{
		dig = num % 10 + '0';
		num = (num - num % 10) / 10;
		counter++;
		tmp = (char *) malloc(sizeof(char) * (counter + 1));
		if (tmp == NULL)
			return (NULL);
		*(tmp + counter) = '\0';
		if (counter == 1)
			*tmp = dig;
		else
			ft_memcpy(lf, tmp, dig);
		if (lf != NULL)
			free(lf);
		lf = tmp;
	}
	return (lf);
}
0 main:
int	main(void)
{
	// int	test;

	// test = 15;
	// printf("%2$+*3$.*1$d %1$d\n", 2, 1, test);
	// printf("%2$-+10.*3$d %1$d\n", 10, 3, 5); //show that it's not compulsory for field and precision an $ style.
	// printf("E%%%iaaaa%20.skkk%-10ubbb%#xWWW%20pZZZ\n", 0, "Holaaaa", 0, -123, &test);
	printf(" %.d \n", INT_MAX);
	printf(" %p \n", -1);
	printf(" %p \n", 1);
	printf(" %p \n", 15);
	printf(" %p \n", 16);
	printf(" %p \n", 17);
	printf(" %p %p \n", LONG_MIN, LONG_MAX);
	printf(" %p %p \n", INT_MIN, INT_MAX);
	printf(" %p %p \n", ULONG_MAX, -ULONG_MAX);
	printf(" %p %p \n", 0, 0);
	printf("Starting my implementation\n");
	ft_printf(" %.d \n", INT_MAX);
	ft_printf(" %p \n", -1);
	ft_printf(" %p \n", 1);
	ft_printf(" %p \n", 15);
	ft_printf(" %p \n", 16);
	ft_printf(" %p \n", 17);
	ft_printf(" %p %p \n", LONG_MIN, LONG_MAX);
	ft_printf(" %p %p \n", INT_MIN, INT_MAX);
	ft_printf(" %p %p \n", ULONG_MAX, -ULONG_MAX);
	ft_printf(" %p %p \n", 0, 0);
	// ft_printf("EEE%%%04.saaa%-15c%-+10.3d%20paaa%#xbbb%010u", "Holaaaa", 'B', 0, &test, -123, 0);
	// printf("\n");
	// ft_printf("E%%%iaaaa%20.skkk%-10ubbb%#xWWW%20pZZZ", 0, "Holaaaa", 0, -123, &test);
	// printf("\n");
	return (0);
}

DEPRECATED FUNCTIONS DUE TO THE RESTRICTIONS ON CFLAGS. (VERY IMPORTANT!)

/*Has been modified the return from the validations constraints because
we are not getting this warnings as errors in the tester time, modify it's
necessary.*/
// static int	ft_nd_cnst(t_map map, char *conv)
// {
// 	unsigned int	*off_map;
// 	unsigned int	*end_map;

// 	off_map = &(map.plus);
// 	end_map = &(map.ppoint);
// 	// if (ft_vldtn_cons(map, conv) == 0)
// 	// 	return (0);
// 	while (off_map <= end_map)
// 	{
// 		if (off_map != &(map.fnum) && off_map != &(map.pnum))
// 			if (*off_map > 1)
// 				return (0);
// 		off_map++;
// 	}
// 	return (1);
// }

/*The ft_nd_cnst function has been setted off because the
constraints have not been considered for all the test well
known so far, this could give us some warnings because we
are compiling without the CFLAGS, having this on consideration
it's important to check wether the molinette compile with or
without CFLAGS.
after: if (nd->prcsn.off != NULL)
			ft_get_maps(..., PRCSN);
		if (ft_nd_cnst(nd->map, root->lm.end) == 0)
			return (0);
We have cut the last validation off because of the constraints
has not been considered to all the tests.*/

/*the constraints validations has been modified due to the way
that the tests known so far take the format string without having
in consideration the CFLAGS when we compile the program, giving us
a program which could output answer ignoring warnings.*/
// int	ft_vldtn_cons(t_map m, char *c)
// {
// 	if (*c == '%')
// 		return (1);
// 	if (m.plus > 0 && ((*c != 'd' && *c != 'i') || m.space > 0))
// 		return (0);
// 	if (m.space > 0 && ((*c != 'd' && *c != 'i' && *c != 's') || m.plus > 0))
// 		return (0);
// 	if (m.ppoint > 0 && (m.zero > 0 || *c == 'p' || *c == 'c'))
// 		return (0);
// 	if (m.hash > 0 && *c != 'x' && *c != 'X')
// 		return (0);
// 	if (m.zero > 0)
// 		if (m.minus > 0 || *c == 's' || *c == 'c' || *c == 'p')
// 			return (0);
// 	if ((m.fstar != 0 && m.fnum != 0) || (m.pstar != 0 && m.pnum != 0))
// 		return (0);
// 	return (1);
// }